# router学习笔记
## 响应路由参数的变化
1. 当使用路由参数的时候，例如从 /user/foo 导航到 /user/bar,原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁在创建，复用则显得更加高效。**不过这也意味着组件的生命周期钩子不会再被调用**
2. 复用组件时，想对路由参数的变化作出响应的话，可以简单的watch $route对象。

## 路由组件传参
* 路由组件传参布尔模式
    * 懂了
- 路由组件传参对象模式
    - 今天懂了
+ 路由组件传参函数模式
    * 今天懂了
## 导航守卫
**`全局前置守卫`**
</br>
可以使用router.beforeEach注册一个全局前置守卫

```js
    const router = new VueRouter({...})
    router.beforeEach((to,from,next)=>{

    })
```

当一个导航触发时，全局前置守卫按照创建顺序调用，守卫是异步解析执行，此时导航在所有守卫resolve完之前一直处于等待之中。
</br>
每个守卫方法接收三个参数：
+ **`to : Route`** :即将要进入的目标 路由对象
+ **`from : Route`** : 当前导航正要离开的路由
+ **`next : Function`** : 一定要调用该方法来resolve这个钩子。执行效果依赖next方法的调用参数。
    - **`next()`** :进行管道中的下一个钩子。如果钩子全部执行完了，则导航的状态就是confirmed(确认的).
    - **`next(false)`** : 中断当前的导航。如果浏览器的URL改变了（可能是用户手动或者浏览器后退按钮）,那么URL地址会重置到 **`from`**路由对应的地址
    - **`next('/')`** **或者** **`next({path:'/'})`**:跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 **`next`** 传递任意位置对象，且允许设置诸如 `replace:true`、`name:'home'`之类的选项以及任何用在`router-link` 的 prop 或者 `router.push`中的选项。
    - **`next(error)`**: （2.4.0+）如果传入`next`的参数是一个Error实例，则导航会被终止且该错误会被传递给`router.onError()`注册过的回调

---
**`全局解析守卫`**
>2.5.0新增

在2.5.0+你可以用router.beforeResolve注册一个全局守卫。这和router.beforeEach类似，区别是在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后**，解析守卫就被调用

---


## 完整的导航解析流程
1. 导航被触发
2. 在失活的组件里调用离开守卫
3. 调用全局的beforeEach守卫
4. 在重用的组件里调用beforeRouteUpdate守卫(2.2+)
5. 在路由配置里调用beforeEnter
6. 解析异步路由组件
7. 在被激活的组件里调用beforeRouteEnter
8. 调用全局的beforeResolve守卫(2.5+)
9. 导航被确认
10. 调用全局的afterEach钩子
11. 触发DOM更新
12. 用创建好的实例调用 beforeRouteEnter守卫中传给next的回调函数
